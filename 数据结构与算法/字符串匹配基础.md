# 字符串匹配基础

> 字符串匹配有两种大类型：
>
> - 一个字符串中查找一个短串。
>
>   比如 **String.indexOf(String str)**
>
> - 一个字符串中同时查找多个短串。
>
>   比如 敏感词过滤。

首先要理解两个概念：**主串** 和 **模式串**。

> 比如，要在字符串A中查找字符串B。A就是主串，B就是模式串。

## 查找单模式串

### BF

> Brute Force「暴力匹配法」。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210201112738031.jpeg" alt="image-20210201112738031" style="zoom: 50%;" />
>
> 假设**主串长度为n**，**模式串长度为m**。
>
> - 把主串「拆」为**n-m+1个长度为m的子串**。
> - 从第一个开始**逐个比对**「按位对比」。

```java
private int bruteForce(String mainStr, String modeStr) {
    int n = mainStr.length();
    int m = modeStr.length();
  	//n-m+1个子串
    for (int i = 0; i <= n - m + 1; i++) {

      	//子串对比
        inner:
        for (int j = 0; j < m; j++) {
            if (modeStr.charAt(j) == mainStr.charAt(j + i)) {
              	//全部相等
                if (j == m - 1) return i;
            } else {
                break inner;
            }
        }

    }
    return -1;
}
```

> 对于主串为"aaaaaaaaa……aaaaaa"，模式串为"aaaaaaab"这样的情况：每次子串对比都要m个全部对比，时间复杂度退化为O(n*m)
>
> 对于日常开发来说，主串长度一般不大，使用这种方式反而效率高「因为简单」。

### RK

> Rabin-Karp算法，由发明者Rabin和Karp名字来命名。
>
> 是RF的升级版本：优化模式串的按位对比。
>
> 思路是：
>
> - 主串求哈希值。
> - 对n-m+1个子串分别求哈希值。
> - 对比哈希值即可。
>
> 但是有个问题：
>
> - 如果**每一个子串求哈希值都需要遍历子串的m个元素**，时间复杂度跟O(n*m)一样。
>
> 需要一个不需要遍历所有子串n*m个元素的哈希值的方法：
>
> 假设字符集中包含K个字符，例如a-z共26个。就可以把子串m个元素看成一个K进制数，转换成10进制数就是哈希值。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210201152355195.png" alt="image-20210201152355195" style="zoom:50%;" />
>
> 设子串哈希函数为h：
>
> $h(i)=主[i]*26^{m-1}+主[i+1]*26^{m-2}+……+主[i+m]$
>
> $h(i+1)=主[i+1]*26^{m-1}+主[i+2]*26^{m-2}+……+主[i+m+1]$
>
> $h[i+1]=(h(i)-主[i]*26^{m-1}) * 26 +主[i+m+1]$
>
> 且$26^0$、$26^1$、$26^2$……$26^{m-1}$这样的计算可以通过一个m-1的数组提前存储。
>
> 
>
> 这样**只有第一个子串需要m个元素全部参与计算**，效率是不是就提高了呢。
>
> 提到哈希函数就不得不提**发生哈希冲突如何处理**问题：
>
> 哈希值相等时，**取出子串按位对比**即可。

```java
/**
 * RK匹配
 * 字符集为a-z 也就是hash(z)=z-a
 */
private int rabinKarp(String mainStr, String modeStr) {
  
  	//26的幂等集合
    int[] ks = new int[modeStr.length()];
    ks[0] = (int) Math.pow(26, modeStr.length() - 1);
    for (int i = 1; i <= modeStr.length() - 1; i++) {
        ks[i] = ks[i - 1] / 26;
    }

    int subNum = mainStr.length() - modeStr.length() + 1;
    int[] hashs = new int[subNum];

    int result = -1;
    int hash0 = 0；
    int hashMode = 0; 
  	//初始化第一个子串和模式串的哈希值
    for (int i = 0; i <= modeStr.length() - 1; i++) {
        hash0 += (mainStr.charAt(i) - 97) * ks[i];
        hashs[0] = hash0;
        hashMode += (modeStr.charAt(i) - 97) * ks[i];
    }

    if (hash0 != hashMode) {
        //子串处理
        for (int i = 1; i <= subNum; i++) {
          	//根据前一子串哈希值计算当前子串的哈希值
            hashs[i] = (hashs[i - 1] - (mainStr.charAt(i - 1) - 97) * ks[0]) * 26 + (mainStr.charAt(i + modeStr.length() - 1) - 97);
            if (hashs[i] == hashMode) {
                result = i;
                break;
            }

        }
    } else {
        result = 0;
    }
  	//哈希冲突校验
    if (result != -1) {
        for (int i = 0; i <= modeStr.length() - 1; i++) {
            if (modeStr.charAt(i) != mainStr.charAt(i + result))
                return -1;
        }
    }


    return result;
}
```



### BM

### KMP

## 查找多模式串

### Trie树

### AC自动机



# String.indexOf源码解析



