# 字符串匹配基础

> 字符串匹配有两种大类型：
>
> - 一个字符串中查找一个短串。
>
>   比如 **String.indexOf(String str)**
>
> - 一个字符串中同时查找多个短串。
>
>   比如 敏感词过滤。

首先要理解两个概念：**主串** 和 **模式串**。

> 比如，要在字符串A中查找字符串B。A就是主串，B就是模式串。

## 查找单模式串

### BF

> Brute Force「暴力匹配法」。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210201112738031.jpeg" alt="image-20210201112738031" style="zoom: 50%;" />
>
> 假设**主串长度为n**，**模式串长度为m**。
>
> - 把主串「拆」为**n-m+1个长度为m的子串**。
> - 从第一个开始**逐个比对**「按位对比」。

```java
private int bruteForce(String mainStr, String modeStr) {
    int n = mainStr.length();
    int m = modeStr.length();
  	//n-m+1个子串
    for (int i = 0; i <= n - m + 1; i++) {

      	//子串对比
        inner:
        for (int j = 0; j < m; j++) {
            if (modeStr.charAt(j) == mainStr.charAt(j + i)) {
              	//全部相等
                if (j == m - 1) return i;
            } else {
                break inner;
            }
        }

    }
    return -1;
}
```

> 对于主串为"aaaaaaaaa……aaaaaa"，模式串为"aaaaaaab"这样的情况：每次子串对比都要m个全部对比，时间复杂度退化为O(n*m)
>
> 对于日常开发来说，主串长度一般不大，使用这种方式反而效率高「因为简单」。

### RK

> Rabin-Karp算法，由发明者Rabin和Karp名字来命名。
>
> 是RF的升级版本：优化模式串的按位对比。
>
> 思路是：
>
> - 主串求哈希值。
> - 对n-m+1个子串分别求哈希值。
> - 对比哈希值即可。
>
> 但是有个问题：
>
> - 如果**每一个子串求哈希值都需要遍历子串的m个元素**，时间复杂度跟O(n*m)一样。
>
> 需要一个不需要遍历所有子串n*m个元素的哈希值的方法：
>
> 假设字符集中包含K个字符，例如a-z共26个。就可以把子串m个元素看成一个K进制数，转换成10进制数就是哈希值。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210201152355195.png" alt="image-20210201152355195" style="zoom:50%;" />
>
> 设子串哈希函数为h：
>
> $h(i)=主[i]*26^{m-1}+主[i+1]*26^{m-2}+……+主[i+m]$
>
> $h(i+1)=主[i+1]*26^{m-1}+主[i+2]*26^{m-2}+……+主[i+m+1]$
>
> $h[i+1]=(h(i)-主[i]*26^{m-1}) * 26 +主[i+m+1]$
>
> 且$26^0$、$26^1$、$26^2$……$26^{m-1}$这样的计算可以通过一个m-1的数组提前存储。
>
> 
>
> 这样**只有第一个子串需要m个元素全部参与计算**，效率是不是就提高了呢。
>
> 提到哈希函数就不得不提**发生哈希冲突如何处理**问题：
>
> 哈希值相等时，**取出子串按位对比**即可。

```java
/**
 * RK匹配
 * 字符集为a-z 也就是hash(z)=z-a
 */
private int rabinKarp(String mainStr, String modeStr) {
  
  	//26的幂等集合
    int[] ks = new int[modeStr.length()];
    ks[0] = (int) Math.pow(26, modeStr.length() - 1);
    for (int i = 1; i <= modeStr.length() - 1; i++) {
        ks[i] = ks[i - 1] / 26;
    }

    int subNum = mainStr.length() - modeStr.length() + 1;
    int[] hashs = new int[subNum];

    int result = -1;
    int hash0 = 0；
    int hashMode = 0; 
  	//初始化第一个子串和模式串的哈希值
    for (int i = 0; i <= modeStr.length() - 1; i++) {
        hash0 += (mainStr.charAt(i) - 97) * ks[i];
        hashs[0] = hash0;
        hashMode += (modeStr.charAt(i) - 97) * ks[i];
    }

    if (hash0 != hashMode) {
        //子串处理
        for (int i = 1; i <= subNum; i++) {
          	//根据前一子串哈希值计算当前子串的哈希值
            hashs[i] = (hashs[i - 1] - (mainStr.charAt(i - 1) - 97) * ks[0]) * 26 + (mainStr.charAt(i + modeStr.length() - 1) - 97);
            if (hashs[i] == hashMode) {
                result = i;
                break;
            }

        }
    } else {
        result = 0;
    }
  	//哈希冲突校验
    if (result != -1) {
        for (int i = 0; i <= modeStr.length() - 1; i++) {
            if (modeStr.charAt(i) != mainStr.charAt(i + result))
                return -1;
        }
    }


    return result;
}
```

### BM

> 对于BF算法，时间复杂度可能会发生退化。
>
> 对于RK算法，设计一个工业级哈希算法并不简单，也可能会发生时间复杂度的退化。
>
> Boyer-Moore算法是比前两种甚至KMP算法都要高效的工业级算法。
>
> 优化策略：
>
> ​	**对滑动的优化**，前面两种方式中子串都是按照+1，+1的方式逐个对比，是一位一位的滑动。
>
> ​	而BM算法引入了「**坏字符规则**」和「**好后缀规则**」，增加了滑动步长。

#### 坏字符规则

> 暴力匹配法子串跟模式串的匹配顺序是向右匹配「从下标为0的位置开始逐一匹配」。
>
> 而BM算法则不是，是向左匹配。往后看，自然就会明白。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210201165525376.jpeg" alt="image-20210201165525376" style="zoom: 33%;" />
>
> - 从后往前，某个字符不匹配。这个字符「主串中的字符」就叫**坏字符**。
>
> - 拿着这个**坏字符在模式串中继续向前查找**
>
>   - 如果模式串中不存在，说明需要把子串「滑动」到坏字符的后一位
>
>     <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210201172229539.png" alt="image-20210201172229539" style="zoom:50%;" />
>
>     **向后滑动m位。**
>
>   - 如果在模式传中存在，说明不能向后滑动m位「可能滑过了」。
>
>     <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210201172752830.png" alt="image-20210201172752830" style="zoom:50%;" />
>     
>     **向后滑动2位。**
>   
> - 向后**滑动i位**。
>
>   这个i怎么来的，由上面两个例子可知：
>
>   把坏字符出现时**模式串中的下标记为si**，**坏字符在模式串中的位置记为xi**「找不到为-1」。
>
>   **i = si - xi**。
>
> - 如果坏字符在模式串中多次出现，选择xi最大的那一个「靠右的那一个」。
>
>   避免滑动过大，错过匹配
>
> 坏字符规则可以使滑动更加高效。比如主串「aaabaaabaaabaaabaaab」模式串「aaaa」，每次都是按照m=4进行滑动，时间复杂度为O(n/m).
>
> 也有可能使得时间复杂度退化为O(n)。比如主串「aaaaaaaaaaaaaaaaaaa」模式串「baaa」，根据si-xi是负数，倒退。所以还需要用到好后缀规则。

#### 好后缀规则

> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210202102240525.png" alt="image-20210202102240525" style="zoom:67%;" />
>
> **当坏字符出现时，模式串中已匹配的部分称为好后缀「U」**。在模式串中，跟好后缀匹配的子串叫做U*。
>
> - **如果U*存在**就把『主串中的好后缀匹配部分』跟 U *对齐。「后移U *下标-U下标位」
>
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210202102912759.png" alt="image-20210202102912759" style="zoom:50%;" />
>
> - **如果U *不存在**，不能直接向后移动（m-U长度）位。
>
>   **要使用U的子串「V」继续V *的查找移动操作。**我举个栗子。
>
>   ![image-20210202110958103](https://gitee.com/wangigor/typora-images/raw/master/image-2021020211095810311111.jpeg)
>
>   - 「bc」后缀找不到U*,如果直接后移m位，错过了匹配串。
>
>   - 使用bc的子串「c」去模式串中查找，经过两步后移操作，匹配到了匹配串。

#### 代码实现



### KMP

## 查找多模式串

### Trie树

### AC自动机



# String.indexOf源码解析



