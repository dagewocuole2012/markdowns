# 堆

> 在二叉树那里提到过：堆是一种特殊的完全二叉树。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210126095558581.png" alt="image-20210126095558581" style="zoom:50%;" />

## 什么是堆

> 堆的条件：
>
> - 堆是一个**完全二叉树**。
>
>   除最后一层外，其他层的元素都是满的；最后一层元素全部靠左。
>
>   按数组表示：1~n所有元素连续。
>
> - **堆中每个节点的元素必须大于等于「或小于等于」其子树中每个节点的值**。
>
>   有两种堆：
>
>   **大顶堆**：堆中的每个节点元素，都**大于等于**其子节点的值。**「大顶堆的堆顶元素是堆的最大元素」**
>
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210126100654816.png" alt="image-20210126100654816" style="zoom:50%;" />
>
>   左右子节点大小不关心，只需要在一个「一父双子的三角形」中，父节点是三个的最大节点即可。
>
>   **小顶堆**：堆中的每个节点元素，都**小于等于**其子节点的值。**「小顶堆的堆顶元素是堆的最小元素」**
>
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210126100958762.png" style="zoom:50%;" />
>   
>   左右子节点大小不关心，只需要在一个「一父双子的三角形」中，父节点是三个的最小节点即可。
>
> 
>
> 完全二叉树使用数组存放很方便「空间小」，不需要记录子节点的引用。
>
> 而且使用下标随机访问的方式可以很快找到父节点和子节点：
>
> **root在下标为1**：那么下标为「$i$」的元素的两个子节点是「$2i$」和「$2i+1$」。父节点是「$\frac{i}2$」。
>
> **root在下标为0**：那么下标为「$i$」的元素的两个子节点是「$2i+1$」和「$2i+2$」。父节点是「$\frac{i-1}2$」。

### 堆中插入元素

> 插入最底层的最左空闲节点「也就是数组的下一个空闲节点」，不论他在那个子树，都逐级跟父节点比较交换，直到父节点大于等于「大顶堆；小于等于：小顶堆」终止。
>
> 拿大顶堆举例：
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210126104226275.png" alt="image-20210126104226275" style="zoom:50%;" />
>
> 用数组表示就是
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210126105350326.png" alt="image-20210126105350326" style="zoom:50%;" />

### 删除堆顶元素

> 按照元素搜索没有意义，因为左右子节点没有规律。
>
> 按照元素删除指定节点也没有意义，只有删除堆顶「最大/最小」才有意义。
>
> <img src="https://gitee.com/wangigor/typora-images/raw/master/image-2021012611150732211.jpeg" alt="image-20210126111507322" style="zoom: 67%;" />
>
> - **删掉「清空」堆顶元素**，用**最后一个元素补位**。
> - 从堆顶节点「关注点」开始，比较当前节点和两个子节点大小，**获取「最大/最小」节点**，进行替换。
> - 再把关注点放在获取到「最大/最小」节点的位置，重复第2步操作，**直到关注点没有子节点**。

### 二叉堆的实现

```java
static class BinaryHeap<T extends Comparable> {

    Class<T> clazz;

    T[] table;
    int num;
    /**
     * 模式：1：大顶堆 -1：小顶堆
     */
    int mod = 1;

    public BinaryHeap(Class<T> clazz) {
        this.clazz = clazz;
        table = (T[]) Array.newInstance(clazz, 2);
    }

    public BinaryHeap(Class<T> clazz, int mod) {
        this.clazz = clazz;
        table = (T[]) Array.newInstance(clazz, 2);
        this.mod = mod;
    }

    /**
     * 扩容
     */
    private void insize() {
        int length = table.length;
        T[] newArray = (T[]) Array.newInstance(this.clazz, length << 1);
        System.arraycopy(table, 0, newArray, 0, length);
        this.table = newArray;
    }

    /**
     * 缩容
     */
    private void desize() {
        int length = table.length;
        T[] newArray = (T[]) Array.newInstance(this.clazz, length >> 1);
        System.arraycopy(table, 0, newArray, 0, num + 1);
        this.table = newArray;
    }

    /**
     * 添加元素
     *
     * @param obj
     */
    public void push(T obj) {
        //最后一层满了先扩容
        if (num == table.length - 1) {
            insize();
        }
        int index = ++num;
        table[index] = obj;
        if (num == 1) return;
        do {

            int parentIndex = index / 2;
            //比较父节点
            if (ObjectUtils.compare(table[parentIndex], obj) * mod < 0) {
                //交换
                table[index] = table[parentIndex];
                table[parentIndex] = obj;
            } else {
                break;
            }
            index = parentIndex;

        } while (index > 1);
    }

    /**
     * 弹出堆顶元素
     */
    public T pop() {
        if (num == 0) return null;

      	//最后一个元素移到堆顶
        T last = table[num];
        T top = table[1];
        table[1] = last;
        table[num--] = null;
				
      	//平衡
        balanceHeap();

        return top;
    }
		
  	/**
     * 平衡
     */
    public void balanceHeap() {

        if (num + 1 <= table.length >> 1) {
            desize();
        }

        int i = 1;
        T current;
        while ((2 * i + 1) < table.length && (current = table[i]) != null) {
            T left = table[2 * i];
            T right = table[2 * i + 1];

          	//比较三个节点的值 并交换
            if (ObjectUtils.compare(left, right) * mod >= 0) {
                if (ObjectUtils.compare(left, current) * mod >= 0) {
                    table[i] = table[2 * i];
                    table[2 * i] = current;
                    i = 2 * i;
                } else {
                    break;
                }
            } else {
                if (ObjectUtils.compare(right, current) * mod >= 0) {
                    table[i] = table[2 * i + 1];
                    table[2 * i + 1] = current;
                    i = 2 * i + 1;
                } else {
                    break;
                }
            }

        }
    }

}
```

## 堆排序

> 堆排序就是使用堆顶「最大/最小」特性来完成的排序。
>
> 堆排序分为两步：
>
> - 建堆。
>
>   使数据符合堆的标准。堆顶元素为最大或最小值。
>
> - 排序。
>
>   一个劲得弹出堆顶元素就完事了。
>
> 需要注意的是，**堆排序是原地排序**「不需要借助外部空间就能完成排序。」

### 建堆

有两种原地建堆的方式。

> - 第一种类似于「插入排序」。假设有n个数据，令第1个元素是堆顶，堆长度为1。把2~n的元素逐个添加入堆中「父节点比较交换」。就完成了建堆的过程。
>
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210127143420759111.jpeg" alt="image-20210127143420759" style="zoom:50%;" />
>
>   要注意的是：这里的top从数组下标为0的位置开始，获取父节点下标公示要换成$\frac{i-1}2$。

以建大顶堆为例

```java
/**
 * 建堆-插入方式
 *
 * @param array
 * @param <T>
 * @return
 */
private <T extends Comparable> T[] buildHeapByInsert(T[] array) {
		//从第二个元素开始
    for (int i = 1; i < array.length; i++) {

        int parent;
        int current = i;
      	//跟父节点比较 交换
        while ((parent = (current - 1) / 2) != i && compare(array[current], array[parent]) > 0) {
            T temp = array[current];
            array[current] = array[parent];
            array[parent] = temp;
            current = parent;
        }

    }

    return array;
}
```

> - 第二种方式是从下往上的逐个子树调整。
>
>   <img src="https://gitee.com/wangigor/typora-images/raw/master/image-20210127145925524.jpeg" alt="image-20210127145925524" style="zoom:50%;" />
>
>   从**最后一个子树**开始，也就是1-10这个子树「**如何获得最后一个子树：最后一个元素的父节点为根的子树**」逐个子树进行调整「**调整整颗子树**」。按照箭头方向「**for( int i=(n-1)/2 ; i<=0 ; i--)**」。完成建堆操作。

以大顶堆为例，使用递归实现

```java
/**
 * 建堆-子树调整方式
 *
 * @param array
 * @param <T>
 * @return
 */
private <T extends Comparable> T[] buildHeapBySubtree(T[] array) {

    //从最后一个子树开始，向前调整
    for (int i = (array.length - 2) / 2; i >= 0; i--) {
        adjustSubtree(array, i);
    }

    return array;
}

/**
 * 以root为根开始子树调整
 *
 * @param array
 * @param root
 * @param <T>
 * @return
 */
private <T extends Comparable> void adjustSubtree(T[] array, int root) {

    int leftIndex = 2 * root + 1;
    int rightIndex = 2 * root + 2;

    T left = leftIndex >= array.length ? null : array[leftIndex];
    T right = rightIndex >= array.length ? null : array[rightIndex];
    //先对比左右
    //再跟大的对比交换
    if (compare(left, right) >= 0) {
        if (compare(array[root], left) <= 0) {
            T temp = array[root];
            array[root] = left;
            array[leftIndex] = temp;
            //以调整节点为根继续向下调整
            adjustSubtree(array, leftIndex);
        }
    //镜像操作    
    } else {
        if (compare(array[root], right) <= 0) {
            T temp = array[root];
            array[root] = right;
            array[rightIndex] = temp;
            adjustSubtree(array, rightIndex);
        }
    }
}
```

这两种方式的调整结果不同，但是目的相同，都是最大元素在堆顶。

**建堆的时间复杂度是O(n).**

### 排序

```java
//把子树调整修改一下
//增加limit参数 代表了heap限制
//当pop了一个元素，放在n位置的时候，对heap开始从头调整，n位置不参与调整。
private <T extends Comparable> void adjustSubtree(T[] array, int root,int limit) {

    int leftIndex = 2 * root + 1;
    int rightIndex = 2 * root + 2;

  	//超过了limit限制的为null
    T left = leftIndex >= limit ? null : array[leftIndex];
    T right = rightIndex >= limit ? null : array[rightIndex];

    if (compare(left, right) >= 0) {
        if (compare(array[root], left) <= 0) {
            T temp = array[root];
            array[root] = left;
            array[leftIndex] = temp;
            adjustSubtree(array, leftIndex,limit);
        }
    } else {
        if (compare(array[root], right) <= 0) {
            T temp = array[root];
            array[root] = right;
            array[rightIndex] = temp;
            adjustSubtree(array, rightIndex,limit);
        }
    }
}
```

```java
/**
 * 建堆之后的排序
 * @param heap
 * @param <T>
 */
private <T extends Comparable> void sort(T[] heap){
  	//持续pop「i与堆顶交换，然后调整堆结构」
    for (int i=heap.length-1;i>=0;i--){
      	//交换
        T temp=heap[i];
        heap[i]=heap[0];
        heap[0]=temp;
      	//调整
        adjustSubtree(heap,0,i);
    }
}
```

> **排序的时间复杂度为O(nlogn)。**

所以堆排序的整体时间复杂度为**O(nlogn)**.

**不是稳定排序**：因为会把元素与堆顶元素交换，破坏稳定度。

>日常排序中不使用堆排序的原因：
>
>- 对cpu缓存不友好
>
>  对于1，2，4，8这样的访问，相比快速排序的局部访问，cpu缓存不友好。
>
>- 对于基本有序数据不友好
>
>  如果一组数据基本有序，也需要重新打乱建堆，再进行重排序。
>
>  也就是堆排序的交换次数普遍较高，而可能是多余的。

## 堆的应用

# 优先级队列PriorityQueue源码解析

