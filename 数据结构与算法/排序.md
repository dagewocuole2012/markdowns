# 排序



## 衡量标准

### 执行效率

之前的算法时间复杂度分析，都是基于**数据量**，反应数据量n很大时候的增长趋势。

但是排序稍有不同，数据**有序性**的不同也会导致时间复杂度的不同『比如一组完全有序的数据，「经过」排序算法的时间复杂度可能是O(n)，因为只有一次遍历；而一组倒序的数据，「经过」排序算法的时间复杂度可能是O($n^2$)』。

以冒泡排序为例「假设数据需要从小到大排列」，n个数据的排列组合方式有 $n!$ 种，使用之前的平均分析，计算每种情况的时间复杂度，再求解平均时间复杂度的方式就会很麻烦，需要涉及到数据推理和大量计算。

> **有序度**和**逆序度**
>
> **有序度**是数据中具有有序关系的数据对个数。以从小到大排序为例，有序关系的数据对可以表示为
>
> ```逻辑公式
> 当i<j时：a[i] <= a[j]
> ```
>
> ```示例
> 「2、4、3、1、5、6」这组数据中，有序的数据对有：
> 「2、4」「2、3」「2、5」「2、6」
> 「4、5」「4、6」
> 「3、5」「3、6」
> 「1、5」「1、6」
> 「5、6」
> 共有11对，所有这组数据的有序度为11。
> ```
>
> ```示例
> 「1、2、3、4、5、6」这组数据，是满有序度，n*(n-1)/2。15。
> 「6、5、4、3、2、1」这组数据，没有一个有序对，0。
> ```
>
> 交换次数总是 **「满有序度-初始有序度」**
>
> ```示例
> 「2、4、3、1、5、6」初始有序度为11，满有序度为15。使用冒泡排序。
> 第一次交换：「2、『3、4』、1、5、6」
> 第二次交换：「2、3、『1、4』、5、6」
> 第三次次交换：「2、『1、3』、4、5、6」
> 第四次次交换：「『1、2』、3、4、5、6」
> 最后一次遍历不交换数据，总共15-11=4次交换。
> ```
>
> **逆序度**跟有序度刚好相反。
>
> ```逻辑公式
> 当i<j时：a[j] > a[j]
> ```
>
> **满有序度 = 逆序度 + 有序度**。排序就是一个增加有序度，减小逆序度的过程。

以冒泡排序为例，经过一次**交换**，**有序度加一**。

- 最好情况：有序度为满有序度，不需要进行交换。

- 最坏情况：有序度为0，需要进行$n(n-1)/2$次交换。
- 平均情况：最好情况和最坏情况取平均值，$n(n-1)/4$

也就是，**冒泡排序的平均时间复杂度为O($n^2$)**。当然这种分析方式并不严格「比较操作比交换操作要多」，但是比起概率论的复杂计算和分析来看，更加实用。

### 空间消耗

这里说的是额外的空间消耗。

- **原地排序**时间复杂度为O(1)。冒泡排序、插入排序、选择排序都是原地排序算法。

### 稳定性

如果存在值相等的元素，经过交换后，他们的先后顺序是否发生改变。

假设有2，9，3，4，8，3一组数据，排序完成后2，3，3，4，8，9。有两个3，如果他们的前后顺序发生变化就是**不稳定排序**；如果前后顺序一致是**稳定排序**。

> 乍一看没什么讲究，但是对于日常的数据排序极为重要。
>
> 假如对订单进行排序，希望按照订单金额从大到小排序，相同订单金额的订单按照下单时间从大到小排序。
>
> - 如果使用不稳定排序：需要对订单金额进行分组，组内按照下单时间排序，然后再对组进行金额排序。比较复杂。
> - 如果使用稳定排序：先按照下单时间排序一遍，再按照订单金额排序一遍，就可以完成。

## 「已排序空间|未排序空间」类型

### 冒泡排序

> 逐个比较相邻的两个元素「i < j」
>
> - 存在 a[i] > a[j]，交换
> - 否则不交换
>
> 一次冒泡，至少会让一个元素移动到它应该在的位置。n个数据，至多经过n次冒泡完成排序。

假设对4，5，6，3，2，1从小到大进行排序，下面是一次冒泡过程

![一次冒泡](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-一次冒泡.png)

经过**一次冒泡**之后，6已经处在正确的位置。那么经过6次排序之后，完成排序。

![image-20201207102759331](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-6次冒泡.png)

6个数据排序6次，不是一个**必要终止排序条件**。

冒泡排序的排序终止条件，应当设为「**当前这一次冒泡是否有数据交换**」，没有数据交换就终止排序。比如下面这组数据：

![image-20201207103731910](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-4次冒泡.png)

没有数据交换，就代表已经达到完全有序的状态。

```java
/**
 * 数组冒泡排序「从小到大」
 *
 * @param array 元素数组
 * @param <T>   实现comparable接口的元素类
 */
private <T extends Comparable> void arrayBubbleSort(T[] array) {

    int array_length = array.length;
    if (array_length <= 1) {
        return;
    }
		//外层最多n次冒泡
    for (int i = 0; i < array_length; i++) {
        boolean changed = false;

        for (int j = 0; j < array_length - 1; j++) {
          	//大于才交换
            if (array[j].compareTo(array[j + 1]) > 0) {
                //需要交换
                T temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
                changed = true;//有交换
            }
        }
        if (!changed) {
            return;//当前循环无交换，退出排序
        }
    }

}
```

> 冒泡排序的衡量：
>
> - 时间复杂度为O($n^2$)
> - 空间复杂度为O(1)，只使用了一个temp的外部空间，是原地排序。
> - 是稳定排序。如果「array[j].compareTo(array[j + 1]) > 0」改为「>=0」，相同的元素，还是稳定排序吗？「依然是，但是会冗余一些交换操作」。

### 插入排序

> 插入排序借由有序数据插入数据而得名。
>
> ![image-20201208100513609](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-有序数据插入元素.png)
>
> 在已有的有序数据中插入新数据，需要将**元素插入指定位置，其他元素后移**。
>
> 由此就有了插入排序算法：将无序数据的第一个数据作为「有序数据」，往后遍历每一个元素，插入有序数据中。
>
> ![image-20201208101903861](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-插入排序.png)
>
> 可以看到：数据满有序度为15，初始有序度为5，总共移动「交换」了10次。**数据交换「移动」次数就是逆序度。**

```java
private <T extends Comparable> void insertionSort(T[] array){
    int array_length=array.length;
    if(array_length<=1) {
        return;
    }

    for (int i = 1; i < array_length; i++) {

        T current=array[i];
        int j=i-1;

        while (j>=0){
            if(array[j].compareTo(current)>0){
                array[j+1]=array[j];//后移
                j--;//比较指针迁移
            }else{
                break;
            }
        }
        //找到位置，插入元素
        array[j+1]=current;
    }
}
```

> 插入排序的衡量：
>
> - 是原地排序。空间复杂度为O(1).
> - 可以是稳定排序。在比较移动时，可以选择在相等元素的后面插入不掉换位置。但不一定是稳定排序
> - 时间复杂度为O($n^2$)。
>
> todo：插入排序有一个希尔排序的优化

### 选择排序

> 选择排序跟插入排序类似。
>
> - 插入排序是，看下一个元素需要插入到有序集合部分的什么位置。
> - 选择排序是，每次从无序集合部分找出最小数据，追加「替换」到有序集合部分。
>
> ![image-20201208105746068](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-选择排序.png)
>
> 这里的逆序度是，最小元素交换了几个位置，依次为跨了3、4、2、0、1、0，逆序度为10.

```java
public <T extends Comparable> void selectionSort(T[] array) {
    int array_length = array.length;
    if (array_length <= 1) {
        return;
    }

    //最后一个就不排了
    for (int i = 0; i < array_length-1; i++) {

        T min=array[i];
        int index_min=i;//最小值节点的下标
        //找到最小值
        for (int j=i;j<array_length;j++){
            T current=array[j];
            if(min.compareTo(current)>0){
                min=current;
                index_min=j;
            }
        }
        //交换
        //如果是自己没必要交换
        if(i!=index_min){
            array[index_min]=array[i];
            array[i]=min;
        }
    }
}
```

> 选择排序的衡量：
>
> - 时间复杂度为O($n^2$)。「即便是最好情况」
> - 空间复杂度O(1)。是原地排序。
> - 是**非稳定排序**。假设「5、2、5、1」这样的数据，首先交换了1和5，两个5的位置就发生了变化。

不使用选择排序，因为**选择排序是非稳定排序**。

**冒泡排序和插入排序，从效率上选择插入排序。**虽然他们的时间复杂度一样，但是交换方式不同：

```java
//插入排序-交换
array[j+1]=array[j];
//冒泡排序-交换
T temp = array[j];
array[j] = array[j + 1];
array[j + 1] = temp;
```

**随着数据量越来越大，性能差距会越来越明显。**

> 我在本机测试结果：
>
> 1000个随机数字排序「原数据相同」
>
> 插入排序：6ms
>
> 冒泡排序：23ms

## 「分治思想」类型

### 归并排序

> 归并排序是一种**分治思想**和**递归技巧**的结合。把一个长集合的排序简化为**子集合**的排序，最小转化为两个**子元素的交换**，再对子集合**合并**。
>
> ![image-20201209154729325](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-归并排序.png)
>
> - 递推公式
>
> ```逻辑
> mergeSort(array,q,p) = merge( mergeSort(array,q,r) , mergeSort(array,r+1,p) );
> # q和p是当前集合的起始下标，r是(q+p)/2的中间下标
> # mergeSort是归并排序公式
> # merge是合并公式
> ```
>
> - 递归终止条件
>
> ```逻辑
> q >= p;
> ```
>
> - merge合并函数
>
> 肯定不能采用元素交换实现。
>
> 需要开辟 temp[q-p]的临时空间，存储排序后的集合。
>
> ![image-20201209163430911](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-归并排序-merge.png)
>
> 最后再将排列好的数据，替换到[q,p]中。

```java
public static <T extends Comparable> void mergeSort(T[] array, int q, int p) {
    //递归终止
    if (q >= p) {
        return;
    }

    //分解
    int r = (q + p) / 2;
    mergeSort(array, q, r);
    mergeSort(array, r + 1, p);

    //合并
    merge(array, q, r, p);
}

private static <T extends Comparable> void merge(T[] array, int q, int r, int p) {
    //临时空间
    T[] temp = (T[]) new Comparable[p - q + 1];
    int left_index = q;
    int right_index = r + 1;

    //排序
    int i = 0;
    while (left_index <= r && right_index <= p) {
        if (array[left_index].compareTo(array[right_index]) > 0) {
            temp[i++] = array[right_index++];
        } else {
            temp[i++] = array[left_index++];
        }
    }

    //数组长度不相等的其余部分
    //优化「这里可以给两个数组都在最后追加一个MAX_VALUE哨兵位，可以省略下面代码」
    while (left_index <= r) {
        temp[i++] = array[left_index++];
    }
    while (right_index <= p) {
        temp[i++] = array[right_index++];
    }

    //覆盖回原数组
    for (int j = 0; j < temp.length; j++) {
        array[q++] = temp[j];
    }
}
```

> 归并排序的衡量：
>
> - 是稳定排序。
>
>   只有在merge方法中涉及到元素位置互换，而我们的方法是「**相等取左边集合元素**」。保证了相等数据原来的顺序。
>
> - 时间复杂度是O($nlogn$)。
>
>   假设对n个元素进行排序，所需时间为T(n)，拆分出来的两个子排序的时间就是T(n/2)。
>
>   对总长度为n的数据merge合并，时间复杂度是O(n)，所需时间也就是n。
>
>   当n=1时，T(1)=一个常量。
>
>   ```公式
>   T(n) = 2*T(n/2) + n
>        = 2*(2*T(n/4)+n/2)+n = 4*T(n/4)+2*n
>        = 4*(2*T(n/8)+n/4) +2*n= 8*T(n/8)+3*n
>        ...
>        = 2^k * T(n/ 2^k) + k*n
>   当n/ 2^k = 1时，
>   有k = logn。
>   T(n) = 2^k * T(n/ 2^k) + k*n
>        = n*T(1) + nlogn
>        = C*n + nlogn
>   ```
>
>   时间复杂度为O(nlogn)
>
> - 空间复杂度是O(n)。
>
>   空间复杂度O(n)有两种理解方式:
>
>   - 可以直接创建一个长度为n的临时数组，用于merge。
>   - 程序在执行时，每一次merge，都会创建一个临时数组，用完销毁，再用再创建。不会同时存在，且，大小都不会超过n

### 快速排序

