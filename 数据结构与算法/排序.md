# 排序



## 衡量标准

### 执行效率

之前的算法时间复杂度分析，都是基于**数据量**，反应数据量n很大时候的增长趋势。

但是排序稍有不同，数据**有序性**的不同也会导致时间复杂度的不同『比如一组完全有序的数据，「经过」排序算法的时间复杂度可能是O(n)，因为只有一次遍历；而一组倒序的数据，「经过」排序算法的时间复杂度可能是O($n^2$)』。

以冒泡排序为例「假设数据需要从小到大排列」，n个数据的排列组合方式有 $n!$ 种，使用之前的平均分析，计算每种情况的时间复杂度，再求解平均时间复杂度的方式就会很麻烦，需要涉及到数据推理和大量计算。

> **有序度**和**逆序度**
>
> **有序度**是数据中具有有序关系的数据对个数。以从小到大排序为例，有序关系的数据对可以表示为
>
> ```逻辑公式
> 当i<j时：a[i] <= a[j]
> ```
>
> ```示例
> 「2、4、3、1、5、6」这组数据中，有序的数据对有：
> 「2、4」「2、3」「2、5」「2、6」
> 「4、5」「4、6」
> 「3、5」「3、6」
> 「1、5」「1、6」
> 「5、6」
> 共有11对，所有这组数据的有序度为11。
> ```
>
> ```示例
> 「1、2、3、4、5、6」这组数据，是满有序度，n*(n-1)/2。15。
> 「6、5、4、3、2、1」这组数据，没有一个有序对，0。
> ```
>
> 交换次数总是 **「满有序度-初始有序度」**
>
> ```示例
> 「2、4、3、1、5、6」初始有序度为11，满有序度为15。使用冒泡排序。
> 第一次交换：「2、『3、4』、1、5、6」
> 第二次交换：「2、3、『1、4』、5、6」
> 第三次次交换：「2、『1、3』、4、5、6」
> 第四次次交换：「『1、2』、3、4、5、6」
> 最后一次遍历不交换数据，总共15-11=4次交换。
> ```
>
> **逆序度**跟有序度刚好相反。
>
> ```逻辑公式
> 当i<j时：a[j] > a[j]
> ```
>
> **满有序度 = 逆序度 + 有序度**。排序就是一个增加有序度，减小逆序度的过程。

以冒泡排序为例，经过一次**交换**，**有序度加一**。

- 最好情况：有序度为满有序度，不需要进行交换。

- 最坏情况：有序度为0，需要进行$n(n-1)/2$次交换。
- 平均情况：最好情况和最坏情况取平均值，$n(n-1)/4$

也就是，**冒泡排序的平均时间复杂度为O($n^2$)**。当然这种分析方式并不严格「比较操作比交换操作要多」，但是比起概率论的复杂计算和分析来看，更加实用。

### 空间消耗

这里说的是额外的空间消耗。

- **原地排序**时间复杂度为O(1)。冒泡排序、插入排序、选择排序都是原地排序算法。

### 稳定性

如果存在值相等的元素，经过交换后，他们的先后顺序是否发生改变。

假设有2，9，3，4，8，3一组数据，排序完成后2，3，3，4，8，9。有两个3，如果他们的前后顺序发生变化就是**不稳定排序**；如果前后顺序一致是**稳定排序**。

> 乍一看没什么讲究，但是对于日常的数据排序极为重要。
>
> 假如对订单进行排序，希望按照订单金额从大到小排序，相同订单金额的订单按照下单时间从大到小排序。
>
> - 如果使用不稳定排序：需要对订单金额进行分组，组内按照下单时间排序，然后再对组进行金额排序。比较复杂。
> - 如果使用稳定排序：先按照下单时间排序一遍，再按照订单金额排序一遍，就可以完成。

## 「已排序空间|未排序空间」类型

### 冒泡排序

> 逐个比较相邻的两个元素「i < j」
>
> - 存在 a[i] > a[j]，交换
> - 否则不交换
>
> 一次冒泡，至少会让一个元素移动到它应该在的位置。n个数据，至多经过n次冒泡完成排序。

假设对4，5，6，3，2，1从小到大进行排序，下面是一次冒泡过程

![一次冒泡](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-一次冒泡.png)

经过**一次冒泡**之后，6已经处在正确的位置。那么经过6次排序之后，完成排序。

![image-20201207102759331](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-6次冒泡.png)

6个数据排序6次，不是一个**必要终止排序条件**。

冒泡排序的排序终止条件，应当设为「**当前这一次冒泡是否有数据交换**」，没有数据交换就终止排序。比如下面这组数据：

![image-20201207103731910](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-4次冒泡.png)

没有数据交换，就代表已经达到完全有序的状态。

```java
/**
 * 数组冒泡排序「从小到大」
 *
 * @param array 元素数组
 * @param <T>   实现comparable接口的元素类
 */
private <T extends Comparable> void arrayBubbleSort(T[] array) {

    int array_length = array.length;
    if (array_length <= 1) {
        return;
    }
		//外层最多n次冒泡
    for (int i = 0; i < array_length; i++) {
        boolean changed = false;

        for (int j = 0; j < array_length - 1; j++) {
          	//大于才交换
            if (array[j].compareTo(array[j + 1]) > 0) {
                //需要交换
                T temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
                changed = true;//有交换
            }
        }
        if (!changed) {
            return;//当前循环无交换，退出排序
        }
    }

}
```

> 冒泡排序的衡量：
>
> - 时间复杂度为O($n^2$)
> - 空间复杂度为O(1)，只使用了一个temp的外部空间，是原地排序。
> - 是稳定排序。如果「array[j].compareTo(array[j + 1]) > 0」改为「>=0」，相同的元素，还是稳定排序吗？「依然是，但是会冗余一些交换操作」。

### 插入排序

> 插入排序借由有序数据插入数据而得名。
>
> ![image-20201208100513609](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-有序数据插入元素.png)
>
> 在已有的有序数据中插入新数据，需要将**元素插入指定位置，其他元素后移**。
>
> 由此就有了插入排序算法：将无序数据的第一个数据作为「有序数据」，往后遍历每一个元素，插入有序数据中。
>
> ![image-20201208101903861](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-插入排序.png)
>
> 可以看到：数据满有序度为15，初始有序度为5，总共移动「交换」了10次。**数据交换「移动」次数就是逆序度。**

```java
private <T extends Comparable> void insertionSort(T[] array){
    int array_length=array.length;
    if(array_length<=1) {
        return;
    }

    for (int i = 1; i < array_length; i++) {

        T current=array[i];
        int j=i-1;

        while (j>=0){
            if(array[j].compareTo(current)>0){
                array[j+1]=array[j];//后移
                j--;//比较指针迁移
            }else{
                break;
            }
        }
        //找到位置，插入元素
        array[j+1]=current;
    }
}
```

> 插入排序的衡量：
>
> - 是原地排序。空间复杂度为O(1).
> - 可以是稳定排序。在比较移动时，可以选择在相等元素的后面插入不掉换位置。但不一定是稳定排序
> - 时间复杂度为O($n^2$)。
>
> todo：插入排序有一个希尔排序的优化

### 选择排序

> 选择排序跟插入排序类似。
>
> - 插入排序是，看下一个元素需要插入到有序集合部分的什么位置。
> - 选择排序是，每次从无序集合部分找出最小数据，追加「替换」到有序集合部分。
>
> ![image-20201208105746068](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-选择排序.png)
>
> 这里的逆序度是，最小元素交换了几个位置，依次为跨了3、4、2、0、1、0，逆序度为10.

```java
public <T extends Comparable> void selectionSort(T[] array) {
    int array_length = array.length;
    if (array_length <= 1) {
        return;
    }

    //最后一个就不排了
    for (int i = 0; i < array_length-1; i++) {

        T min=array[i];
        int index_min=i;//最小值节点的下标
        //找到最小值
        for (int j=i;j<array_length;j++){
            T current=array[j];
            if(min.compareTo(current)>0){
                min=current;
                index_min=j;
            }
        }
        //交换
        //如果是自己没必要交换
        if(i!=index_min){
            array[index_min]=array[i];
            array[i]=min;
        }
    }
}
```

> 选择排序的衡量：
>
> - 时间复杂度为O($n^2$)。「即便是最好情况」
> - 空间复杂度O(1)。是原地排序。
> - 是**非稳定排序**。假设「5、2、5、1」这样的数据，首先交换了1和5，两个5的位置就发生了变化。

不使用选择排序，因为**选择排序是非稳定排序**。

**冒泡排序和插入排序，从效率上选择插入排序。**虽然他们的时间复杂度一样，但是交换方式不同：

```java
//插入排序-交换
array[j+1]=array[j];
//冒泡排序-交换
T temp = array[j];
array[j] = array[j + 1];
array[j + 1] = temp;
```

**随着数据量越来越大，性能差距会越来越明显。**

> 我在本机测试结果：
>
> 1000个随机数字排序「原数据相同」
>
> 插入排序：6ms
>
> 冒泡排序：23ms

## 「分治思想」类型

### 归并排序

> 归并排序是一种**分治思想**和**递归技巧**的结合。把一个长集合的排序简化为**子集合**的排序，最小转化为两个**子元素的交换**，再对子集合**合并**。
>
> ![image-20201209154729325](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-归并排序.png)
>
> - 递推公式
>
> ```逻辑
> mergeSort(array,q,p) = merge( mergeSort(array,q,r) , mergeSort(array,r+1,p) );
> # q和p是当前集合的起始下标，r是(q+p)/2的中间下标
> # mergeSort是归并排序公式
> # merge是合并公式
> ```
>
> - 递归终止条件
>
> ```逻辑
> q >= p;
> ```
>
> - merge合并函数
>
> 肯定不能采用元素交换实现。
>
> 需要开辟 temp[q-p]的临时空间，存储排序后的集合。
>
> ![image-20201209163430911](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-归并排序-merge.png)
>
> 最后再将排列好的数据，替换到[q,p]中。

```java
public static <T extends Comparable> void mergeSort(T[] array, int q, int p) {
    //递归终止
    if (q >= p) {
        return;
    }

    //分解
    int r = (q + p) / 2;
    mergeSort(array, q, r);
    mergeSort(array, r + 1, p);

    //合并
    merge(array, q, r, p);
}

private static <T extends Comparable> void merge(T[] array, int q, int r, int p) {
    //临时空间
    T[] temp = (T[]) new Comparable[p - q + 1];
    int left_index = q;
    int right_index = r + 1;

    //排序
    int i = 0;
    while (left_index <= r && right_index <= p) {
        if (array[left_index].compareTo(array[right_index]) > 0) {
            temp[i++] = array[right_index++];
        } else {
            temp[i++] = array[left_index++];
        }
    }

    //数组长度不相等的其余部分
    //优化「这里可以给两个数组都在最后追加一个MAX_VALUE哨兵位，可以省略下面代码」
    while (left_index <= r) {
        temp[i++] = array[left_index++];
    }
    while (right_index <= p) {
        temp[i++] = array[right_index++];
    }

    //覆盖回原数组
    for (int j = 0; j < temp.length; j++) {
        array[q++] = temp[j];
    }
}
```

> 归并排序的衡量：
>
> - 是稳定排序。
>
>   只有在merge方法中涉及到元素位置互换，而我们的方法是「**相等取左边集合元素**」。保证了相等数据原来的顺序。
>
> - 时间复杂度是O($nlogn$)。
>
>   假设对n个元素进行排序，所需时间为T(n)，拆分出来的两个子排序的时间就是T(n/2)。
>
>   对总长度为n的数据merge合并，时间复杂度是O(n)，所需时间也就是n。
>
>   当n=1时，T(1)=一个常量。
>
>   ```公式
>   T(n) = 2*T(n/2) + n
>        = 2*(2*T(n/4)+n/2)+n = 4*T(n/4)+2*n
>        = 4*(2*T(n/8)+n/4) +2*n= 8*T(n/8)+3*n
>        ...
>        = 2^k * T(n/ 2^k) + k*n
>   当n/ 2^k = 1时，
>   有k = logn。
>   T(n) = 2^k * T(n/ 2^k) + k*n
>        = n*T(1) + nlogn
>        = C*n + nlogn
>   ```
>
>   时间复杂度为O(nlogn)
>
> - 空间复杂度是O(n)。
>
>   空间复杂度O(n)有两种理解方式:
>
>   - 可以直接创建一个长度为n的临时数组，用于merge。
>   - 程序在执行时，每一次merge，都会创建一个临时数组，用完销毁，再用再创建。不会同时存在，且，大小都不会超过n

### 快速排序

> 快速排序和归并排序都是分治递归。
>
> 但是却**「完全相反」**，归并排序是在递归合并『回溯』的时候，把已经排序好的集合进行合并。而快速排序是把一个大集合逐步分成多个小集合完成排序，没有回溯环节。
>
> ![image-20201210160226124](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-快速排序.png)
>
> 过程：在集合中，找到一个随机的「**分界点**（简单的使用最后一个节点作为分界点）」pivot。遍历整个集合，把小于分界点的数据节点移到分界点左侧；把大于分界点的数据节点移到分界点右侧。然后分别对左右两个子集合进行快速排序。
>
> 根据分界点对集合进行拆分的方法「partition」，在快速排序中是一个空间复杂度为O(1)的方法，比归并排序更优化。
>
> ![image-20201210163510750](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-快速排序-partition.png)
>
> 两个指针，一个分界指针「q」,一个遍历指针「p」
>
> - 当遍历到的元素**小于**分界元素「pivot」时，说明这个元素应该在分解元素左侧，**分界指针右移**。
>
>   并**交换**遍历元素和分解指针指向的元素「如果是同一个元素，可以不交换，比如4」。
>
> - 当遍历到的元素**大于等于**分界元素「pivot」时，说明这个元素应该在分解元素右侧，**分解指针不动**。
>
> - 最后**交换pivot和分界**指向的两个元素。

```java
public static <T extends Comparable> void quickSort(T[] array, int start, int end) {

    //只有一个元素或者没有元素就不排了
    if (end - start < 1) {
        return;
    }
    
    int pivot = partition(array, start, end);

    quickSort(array, start, pivot - 1);
    quickSort(array, pivot + 1, end);
}

public static <T extends Comparable> int partition(T[] array, int start, int end) {
    int i = start, j = start;
    T pivot = array[end];
    for (; i < end; i++) {
        if (array[i].compareTo(pivot) < 0) {
            if(i!=j) {//同一个元素不需要交换
                T temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
            j++;
        }
    }
  	
    array[end] = array[j];
    array[j] = pivot;
    return j;
}
```

> 快速排序的衡量：
>
> - 时间复杂度为O(nlogn)。跟归并排序一样。
> - 空间复杂度为O(1)。是原地排序。
> - 是**不稳定排序**。比如「6、7、6、3、4、5」，经过第一次partition之后，两个6前后位置变化。
>
> 快速排序有因为我们每次都选择最后一个节点作为分界点，如果原数据是有序的或者接近有序的，快速排序的时间复杂度最坏，是O($n^2$)。**分界点的选择不合理**。理想情况下，选出来的分界点应该在中间位置。
>
> - 三数取中法
>
>   从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。
>
> - 随机法
>
>   随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。

==**寻找无序数组的第N大元素**==

就可以使用这种思路:

- 定一个随机点。
- 左侧区间为小于随机点的子集合，右侧为大于随机点的子集合。
- 判断随机点下标跟N的关系，得出第N大元素所在子集合。
- 递归开始，直到找到N。

时间复杂度为$n+n/2+n/4+n/8+...+1$=2n-1。也就是O(n)。

> 这个O(n)还是跟使用选择排序思想的O(n)不一样，选择排序思想，每次取一个最大值，直到取到第N大元素，时间复杂度为O(N*n)。**只有当N小于等于2时，使用选择排序思想才有可能比快排的查找时间复杂度低。**

***

**分治思想还可以体现在一些外部大文件排序上。**

比如一个10G的文件，要对里面的数据进行排序。

- 顺序读取，拆分成20个512M的小文件。
- 在内存中对每个小文件中的数据进行排序。
- 排序完成后，在内存中创建一个长度为20的数组。
- 从每一个文件中，读取一条数据放入内存数组中。
- 比较内存数组中数据大小，取最小值，写入新文件。
- 再从获取到最小值的文件中，读取一条数据，放入集合，在进行比较。
- 依次执行下去，直到所有文件读完。

## 「线性排序」类型

> 线性排序，本质也是基于分治思想的排序，但不像前面的基于集合区间的分治方式，而是采用按照类型区分分治。同时可以不是基于数据比较的排序方式。时间复杂度为O(n)。
>
> 但是线性排序对数据有严格的要求。

### 桶排序

> ![image-20201211145746410](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-桶排序.png)
>
> 将全部数据按照排序字段，划分出多个桶，比如已知排序订单金额大小在0-50万区间。
>
> - 划分出[0-9]、[10-19]、[20-29]、[30-39]、[40-49]五个桶
> - 遍历所有数据，对应放入桶中。
> - 再逐个对桶中的数据进行排序，比如快速排序。
> - 依次按照桶顺序读取数据。
>
> 跟前面分治算法处理10G数据文件不同的是，桶本身就有上下限的限制，桶是有序的。
>
> 假设n个数据分了k个桶。那么k个桶内的数据排序的时间复杂度是O($n/k*logn/k$)，加上遍历n个数据的时间复杂度O(n)，总时间复杂度为  $k*O(n/k*logn/k)+O(n)$。k越大越接近n时，总时间复杂度约等于O(n)。
>
> 有两个问题：
>
> - 如果一个桶中的数据太多，则需要再对桶的槽位进行更细划分。
> - 如果不确定数据上下线，需要遍历得到上下线。
>
> **桶排序比较适用于外部排序。**
>
> 桶排序的衡量：
>
> - 不是原地排序。空间复杂度为O(n)。
> - 可以是稳定排序。取决于桶内数据排序方式。
> - 时间复杂度。O(n)

### 计数排序

> **计数排序是桶排序的特例**，当数值区间不是段而是点的时候，就是计数排序。
>
> 计数排序适用于一些特殊数据的排序，比如年龄、成绩等等。
>
> 以成绩为例：10个学生，成绩是0~5分，有数据[2、4、5、2、3、4、5、3、2、0]
>
> ![image-20201211152934236](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-计数排序-原数据.png)
>
> - 创建一个长度为6的数组。分别对应0~5分的成绩。
> - **遍历**数据，对每个成绩分值进行**计数**。
>
> ![image-20201211153009897](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-计数排序-计数.png)
>
> - 数组遍历，**顺序求和**。
>
> ![image-20201211153243697](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-计数排序-顺序求和.png)
>
> ​		数组中的每一个数据代表了：**小于等于当前元素的数量。**
>
> - 遍历原数据，根据数据所在数组的计数，将数据移入新数组。
>
>   比如第一个数据2，在数组中对应4「说明小于等于2的数据有四个」，在新数组中2应该放在「4-1」的下标中。然后数组中对应计数减一「标识下一个2再来的时候，需要放在「3-1」的位置」
>
> ![image-20201211160630880](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-计数排序.png)

```java
/**
 * 对学生成绩的计数排序
 * 成绩：0~5分
 *
 * @param students
 */
private Student[] countingSort4Score(Student[] students) {

    //初始化计数数组
    int[] countingArray = new int[6];

    //计数
    for (int i = 0; i < students.length; i++) {
        countingArray[students[i].getScore()]++;
    }

    //数组顺序求和
    for (int i = 1; i < countingArray.length; i++) {
        countingArray[i] += countingArray[i - 1];
    }

    //放入新数组,倒序遍历
    Student[] orderedStudents = new Student[students.length];
    for (int i = students.length-1; i >=0; i++) {
        int index = countingArray[students[i].getScore()]-- - 1;
        orderedStudents[index] = students[i];
    }

    return orderedStudents;
}

@Data
@AllArgsConstructor
class Student {
    private String name;
    private int score;
}
```

计数排序只能用在**数据范围不大的场景**中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，**转化为非负整数**。

> 计数排序的衡量：
>
> - 不是原地排序。空间复杂度是O(k).
> - 可以是稳定排序。在最后放进新数组时，需要倒序遍历。
> - 时间复杂度为O(n)

### 基数排序

> 桶排序和计数排序，是排序字段在一定范围的情况。
>
> **基数排序是，排序字段是若干个在一定范围内的字段的组合。**比如电话号码「每一位都在0-9范围内」、单词「每一位都在a-z范围内」等等，他们有一个共同特点，就是从前往后元素的同一位比另一元素大，那么这个元素就大。
>
> 以电话号码来说，不可能给每一种可能的数字排列方式都创建一个计数器。但是电话是每一位都在0-9区间内的11位数字。
>
> 那么，按照10-0的顺序从后往前进行11次排序，采用时间复杂度为O(n)的桶排序「稳定排序」，就可以完成整个排序。

```java
/**
 * 电话号码排序
 *
 * @param telephoneNumbers
 */
private String[] arrayRadixSort(String[] telephoneNumbers) {

    //11次计数排序
    for (int i = 10; i >= 0; i--) {
        telephoneNumbers = countingSort(telephoneNumbers, i);
    }

    return telephoneNumbers;
}

/**
 * 基于下标的计数排序
 * @param telephoneNumbers
 * @param index 下标
 * @return
 */
private String[] countingSort(String[] telephoneNumbers, int index) {
    String[] results = new String[telephoneNumbers.length];
    int[] countingArray = new int[10];

    for (int i = 0; i < telephoneNumbers.length; i++) {
        int currentNum = getIntByIndex(telephoneNumbers[i],index);
        countingArray[currentNum]++;
    }

    for (int i = 1; i < countingArray.length; i++) {
        countingArray[i] += countingArray[i - 1];
    }

    for (int i = telephoneNumbers.length - 1; i >= 0; i--) {
        int currentNum = getIntByIndex(telephoneNumbers[i],index);
        int currentIndex = countingArray[currentNum]-- - 1;
        results[currentIndex] = telephoneNumbers[i];
    }

    return results;
}

private int getIntByIndex(String str, int index) {
    return Integer.valueOf(String.valueOf(str.charAt(index)));
}
```

> 基数排序的衡量：
>
> - 空间复杂度：O(n)。每个维度排序都要创建一个同等大小的空间。
> - 时间复杂度：O(n)。其实是O(n)*维度。
> - 可以是稳定排序。取决于每个维度的排序算法的稳定度。

但是对于单词排序，因为每个单词长度不同。

可以选择使每个单词都用右侧补零的方式变成一样长度的单词「字母的ascII码都大于0」。

## 排序选择

| 算法名称 | 时间复杂度     | 空间复杂度   | 是否稳定排序 |
| -------- | -------------- | ------------ | ------------ |
| 冒泡排序 | O($n^2$)       | O(1)原地排序 | 是           |
| 插入排序 | O($n^2$)       | O(1)原地排序 | 是           |
| 选择排序 | O($n^2$)       | O(1)原地排序 | 不是         |
| 归并排序 | O(nlogn)       | O(n)         | 是           |
| 快速排序 | O(nlogn)       | O(1)原地排序 | 不是         |
| 桶排序   | O(n)           | O(n)         | 是           |
| 计数排序 | O(n+k) k是范围 | O(n)         | 是           |
| 基数排序 | O(k*n) k是维度 | O(n)         | 是           |

### 递归深度问题

> 假如我们选择了不稳定的快速排序方法作为通用数据排序，还需要解决的是递归深度的问题。递归层级过深可能会导致栈溢出。
>
> 可以使用手动实现栈来代替递归操作。

```java
/**
 * 「快速排序」自定义栈实现递归
 */
public static <T extends Comparable> void customStackQuickSort(T[] array, int start, int end) {
    //定义一个栈
    Stack<Integer> indexStack = new Stack<>();
  	//按照左区间、右区间的顺序，把下标压入栈。
    indexStack.push(start);
    indexStack.push(end);
    while (!indexStack.isEmpty()) {
      	//按右区间、左区间方式，获取区间下标
        int right = indexStack.pop();
        int left = indexStack.pop();
				
      	//只处理有长度的部分
        if (right > left) {
          	//获取分界点
            int pivot = partition(array, left, right);
          	//小于分界点的下标入栈
            indexStack.push(left);
            indexStack.push(pivot-1);
          	//大于分界点的下标入栈
            indexStack.push(pivot + 1);
            indexStack.push(right);
        }
    }
}
```

### Arrays.sort/Collections.sort源码解析

> 因为线性排序使用场景较少，作为通用数据排序肯定不会选择线性排序。
>
> 那么O(nlogn)的快速排序和递归排序，因为稳定度不同，jdk也作出了不同的策略选择：
>
> - 基础数据类型以**快速排序**为主，且使用了**双轴快排**
> - 其他数据类型「实现了Comparable接口的」以**归并排序**为主
>
> 并且根据数据量大小，使用了了O($n^2$)的**插入排序**「原地排序」等进行性能优化。

#### 基础数据类型

```java
public static void sort(int[] a) {
  	//双轴快排
    DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
}
```

##### 有序检测和归并

```java
/**
 * a :要排序的数组
 * left :要排序数组的起始下标
 * right :要排序数组的最后元素下标
 * work :工作数组「也就是进行快排的temp数组，可以率先指定，如果不指定会自动创建」
 * workBase :工作数组可用区间的起始下标
 * workLen :工作数组可用长度
 */
static void sort(int[] a, int left, int right,
                 int[] work, int workBase, int workLen) {
    //排序长度小于286的使用双轴快速排序
    if (right - left < QUICKSORT_THRESHOLD) {
        sort(a, left, right, true);
        return;
    }

		//先查看数据是否基本有序
  	//比如8、5、3、2、9、6、4、1、2、4、6、8这样的数据，从第一个数据开始找到降序组/升序组
  	//「8、5、3、2」『9、6、4、1』是两个降序组，降序组翻转『2、3、5、8』『1、4、6、9』
  	//「2、4、6、8」是升序组 升序组不变
  	//进行这样的升序降序分组之后，会变成锯齿形分段升序
  	//如果基本有序「升序组数小于68次」：使用归并排序
  	//如果基本无序「升序组数大于68次」：采用双轴快排
    int[] run = new int[MAX_RUN_COUNT + 1];
    int count = 0; run[0] = left;

    //开始68轮进行是否有序检测
    for (int k = left; k < right; run[count] = k) {
      	//升序组
      	//记录升序组的最远下标
        if (a[k] < a[k + 1]) {
            while (++k <= right && a[k - 1] <= a[k]);
        //降序组
        //记录降序组的最远下标
        //并反转降序组为升序组
        } else if (a[k] > a[k + 1]) {
            while (++k <= right && a[k - 1] >= a[k]);
            for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                int t = a[lo]; a[lo] = a[hi]; a[hi] = t;
            }
        //有相等数据
        //相等的数据长度有32个就直接使用双轴快排
        } else {
            for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {
                if (--m == 0) {
                    sort(a, left, right, true);
                    return;
                }
            }
        }
				//升序组个数到达68，说明基本无序，使用双轴快排
        if (++count == MAX_RUN_COUNT) {
            sort(a, left, right, true);
            return;
        }
    }

  
    // 特殊情况处理
    // 如果最后一个降序组只包含一个元素，为数组添加一个right++的哨兵
  	//run[0]一定是0，count是right+1
  	//8、5、3、2、9、6、4、1、2、4、6、8...这样的数据对应的run是[0，4，8，12...]
    if (run[count] == right++) {
        run[++count] = right;
    //如果只有一个降序组，说明已经有序了。
    } else if (count == 1) {
        return;
    }

    //确定count是2的奇偶次幂
  	//8是2的3次幂 odd=0
  	//9「16」是2的4次幂 odd=1
  	//因为只有一个temp数组。两两合并时，最后是要把temp合并到a，那奇数次方需要从temp到a开始。
  	//而偶数次方需要从a合并到temp开始
  	//比方有8个降序组，奇数，先把整个8个降序组合并到4个降序组「temp->a」,再把4个降序组合并到2个降序组「a->temp」,再把两个降序组合并成一个「temp->a」
    byte odd = 0;
    for (int n = 1; (n <<= 1) < count; odd ^= 1);

    
    int[] b;                 // 临时合并数组
    int ao, bo;              // array offsets from 'left'
    int blen = right - left; // 排序数据全长
  	//如果work空间不足，创建一个等长O(n)的数组「为了合并数据使用」
    if (work == null || workLen < blen || workBase + blen > work.length) {
        work = new int[blen];
        workBase = 0;
    }
  
    if (odd == 0) {
      	//把整个要排序对象a，拷贝进排序空间work中
        System.arraycopy(a, left, work, workBase, blen);
        b = a;//b指向原数据a
        bo = 0;
        a = work;//a指向工作空间
        ao = workBase - left;
    } else {
        b = work;//b指向工作空间，a不动
        ao = 0;
        bo = workBase - left;
    }

    // 归并
  	// 外层循环直到count=1，只剩一个降序组时完成排序
  	// 把a中的数据合并到b中。
    for (int last; count > 1; count = last) {
      	//内层循环将相邻两个降序组合并
        for (int k = (last = 0) + 2; k <= count; k += 2) {
          	//合并k-1和k-2
            int hi = run[k], mi = run[k - 1];
          	//p是k-2组的遍历指针 初始为k-2的最小值
          	//q是k-1组的遍历指针 初始为k-1的最小值
            for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {
              	//合并到b中「长度不齐的也在这里」
                if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                    b[i + bo] = a[p++ + ao];
                } else {
                    b[i + bo] = a[q++ + ao];
                }
            }
          	//在run中记录当前这一次k-1和k-2合并完成的最大下标也就是run[k]
            run[++last] = hi;
        }
      	//如果count是奇数
        if ((count & 1) != 0) {
          	//把剩余的那个降序组移入b中
            for (int i = right, lo = run[count - 1]; --i >= lo;
                b[i + bo] = a[i + ao]
            );
            run[++last] = right;
        }
      	//调换a/b
      	//调换ao/bo
        int[] t = a; a = b; b = t;
        int o = ao; ao = bo; bo = o;
    }
}
```

##### 双轴快排

```java
/**
 * 对要排序数组的指定区间进行双轴快排
 * @param a 要排序数组
 * @param left 起始下标
 * @param right 末尾下标
 * @param leftmost 要排序段是不是位于a最左侧
 */
private static void sort(int[] a, int left, int right, boolean leftmost) {
  	//排序数组全长
    int length = right - left + 1;

    // 小于47个元素，使用插入排序
    if (length < INSERTION_SORT_THRESHOLD) {
      	//如果要排序段位于a最左侧
        if (leftmost) {
            //使用传统的插入排序
            for (int i = left, j = i; i < right; j = ++i) {
                int ai = a[i + 1];
                while (ai < a[j]) {
                    a[j + 1] = a[j];
                    if (j-- == left) {
                        break;
                    }
                }
                a[j + 1] = ai;
            }
        } else {
            //跳过开始部分最长的升序端
            do {
                if (left >= right) {
                    return;
                }
            } while (a[++left] >= a[left - 1]);
						//从left取出两个元素
          	//因为主要涉及元素移动，为了减少移动次数，两个两个元素的移动，这就需要左侧有数据。
            for (int k = left; ++left <= right; k = ++left) {
                int a1 = a[k], a2 = a[left];

              	//比较大的元素是a1
                if (a1 < a2) {
                    a2 = a1; a1 = a[left];
                }
              	//先把较大的元素移动到对的位置
                while (a1 < a[--k]) {
                    a[k + 2] = a[k];
                }
                a[++k + 1] = a1;
								
              	//再把较小的元素移动到正确的位置
                while (a2 < a[--k]) {
                    a[k + 1] = a[k];
                }
                a[k + 1] = a2;
            }
          
          	//最后一个元素移动到正确位置「奇数个会移动，偶数个不需要」
            int last = a[right];
            while (last < a[--right]) {
                a[right + 1] = a[right];
            }
            a[right + 1] = last;
        }
        return;
    }

    // length / 7的近似算法版本（length* 9/64  + 1）。「todo 真没看懂」
    int seventh = (length >> 3) + (length >> 6) + 1;

		
  	//整个要排序数组7「不等分」
  	// +---------------------------------------+
  	// | 1.5/7 | 1/7 | 1/7 | 1/7 | 1/7 | 1.5/7 |
  	// e0      e1    e2    e3    e4    e5      e6
  	// +---------------------------------------+
  	//中间总共取5个指针,左右e0和e5总共占3/7
    int e3 = (left + right) >>> 1; // The midpoint
    int e2 = e3 - seventh;
    int e1 = e2 - seventh;
    int e4 = e3 + seventh;
    int e5 = e4 + seventh;

    //手动对这五个点的数据进行排序
    if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }

    if (a[e3] < a[e2]) { int t = a[e3]; a[e3] = a[e2]; a[e2] = t;
        if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }
    }
    if (a[e4] < a[e3]) { int t = a[e4]; a[e4] = a[e3]; a[e3] = t;
        if (t < a[e2]) { a[e3] = a[e2]; a[e2] = t;
            if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }
        }
    }
    if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t;
        if (t < a[e3]) { a[e4] = a[e3]; a[e3] = t;
            if (t < a[e2]) { a[e3] = a[e2]; a[e2] = t;
                if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }
            }
        }
    }

    // Pointers
    int less  = left;  // The index of the first element of center part
    int great = right; // The index before the first element of right part

    if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {
        //取e2和e4作为两个pivot
        int pivot1 = a[e2];
        int pivot2 = a[e4];
				//可以理解为两个null节点，最后还得替换回去
        a[e2] = a[left];
        a[e4] = a[right];

        //找到左侧天然小于pivot1的区间 和 右侧天然大于pivot2的区间
        while (a[++less] < pivot1);
        while (a[--great] > pivot2);

        /*
         * Partitioning:
         *
         *   left part           center part                   right part
         * +--------------------------------------------------------------+
         * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |
         * +--------------------------------------------------------------+
         *               ^                          ^       ^
         *               |                          |       |
         *              less                        k     great
         *
         * Invariants:
         *
         *              all in (left, less)   < pivot1
         *    pivot1 <= all in [less, k)     <= pivot2
         *              all in (great, right) > pivot2
         *
         * Pointer k is the first index of ?-part.
         */
      	//遍历less到great中间的部分
      	//使用less和great两个活动的pivot「轴」，从两端开始，把整个要排序区间划为「...less...great...」三个区间
        outer:
        for (int k = less - 1; ++k <= great; ) {
            int ak = a[k];
          	//如果元素小于pivot1，放入左侧区间「跟less交换位置」
          	//less右移
            if (ak < pivot1) { 
                a[k] = a[less];
                /*
                 * Here and below we use "a[i] = b; i++;" instead
                 * of "a[i++] = b;" due to performance issue.
                 *
                 * a[i++]=b 可以理解为
                 * mov temp i
                 * inc i
                 * mov a[temp] b

                 * a[i]=b; i++ 可以理解为
                 * mov a[i]=b
                 * inc i
                 * 但是我没测出差异，class也都是一样的。应该是被编译器优化掉了。
                 */
                a[less] = ak;
                ++less;
            //如果元素大于pivot2，放入右侧区间「跟great交换位置」
            //great左移
            } else if (ak > pivot2) {
              	//如果置换出来的greate节点大于pivot2，说明两个元素都应该在右侧区间
              	//一直找到小于等于右区间边界的元素，如果到k了，说明「k，greate」之间的所有元素都应该在右区间，已经完成全部中间数据的遍历
                while (a[great] > pivot2) {
                    if (great-- == k) {
                        break outer;
                    }
                }
              	//如果置换出来的元素属于左侧区间，放入左侧区间，less右移
                if (a[great] < pivot1) {
                    a[k] = a[less];
                    a[less] = a[great];
                    ++less;
                //属于中间区间
                } else {
                    a[k] = a[great];
                }
               	//greate左移
                a[great] = ak;
                --great;
            }
        }

        // 把两个pivot放入所在的less和great位置
        a[left]  = a[less  - 1]; a[less  - 1] = pivot1;
        a[right] = a[great + 1]; a[great + 1] = pivot2;

      	//开始递归
        //对pivot1左侧的区间进行双轴快排
      	//对pivot2右侧的区间进行双轴快排
        sort(a, left, less - 2, leftmost);
        sort(a, great + 2, right, false);

        //如果中间区域还是太大，占了整个要排序区间总大小的4/7以上
        if (less < e1 && e5 < great) {
            //先跳过中间等于两个pivot的元素
            while (a[less] == pivot1) {
                ++less;
            }
            while (a[great] == pivot2) {
                --great;
            }

            /*
             * Partitioning:
             *
             *   left part         center part                  right part
             * +----------------------------------------------------------+
             * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |
             * +----------------------------------------------------------+
             *              ^                        ^       ^
             *              |                        |       |
             *             less                      k     great
             *
             * Invariants:
             *
             *              all in (*,  less) == pivot1
             *     pivot1 < all in [less,  k)  < pivot2
             *              all in (great, *) == pivot2
             *
             * Pointer k is the first index of ?-part.
             */
            outer:
            for (int k = less - 1; ++k <= great; ) {
                int ak = a[k];
                if (ak == pivot1) { // Move a[k] to left part
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else if (ak == pivot2) { // Move a[k] to right part
                    while (a[great] == pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] == pivot1) { // a[great] < pivot2
                        a[k] = a[less];
                        a[less] = pivot1;
                        ++less;
                    } else { // pivot1 < a[great] < pivot2
                        a[k] = a[great];
                    }
                    a[great] = ak;
                    --great;
                }
            }
        }
      	//经过上面这一步区分出了三块区间[ ==pivot1 , >pivot1 <pivot2 , ==pivot2 ]
        //对中间>pivot1 <pivot2进行双轴快排
        sort(a, less, great, false);

    } else {
      	//如果5个点有数据相等，取中间的e3进行传统的快排
        int pivot = a[e3];
        /*
         * Partitioning degenerates to the traditional 3-way
         * (or "Dutch National Flag") schema:
         *
         *   left part    center part              right part
         * +-------------------------------------------------+
         * |  < pivot  |   == pivot   |     ?    |  > pivot  |
         * +-------------------------------------------------+
         *              ^              ^        ^
         *              |              |        |
         *             less            k      great
         *
         * Invariants:
         *
         *   all in (left, less)   < pivot
         *   all in [less, k)     == pivot
         *   all in (great, right) > pivot
         *
         * Pointer k is the first index of ?-part.
         */
        for (int k = less; k <= great; ++k) {
            if (a[k] == pivot) {
                continue;
            }
            int ak = a[k];
            if (ak < pivot) { // Move a[k] to left part
                a[k] = a[less];
                a[less] = ak;
                ++less;
            } else { // a[k] > pivot - Move a[k] to right part
                while (a[great] > pivot) {
                    --great;
                }
                if (a[great] < pivot) { // a[great] <= pivot
                    a[k] = a[less];
                    a[less] = a[great];
                    ++less;
                } else { // a[great] == pivot
                    /*
                     * Even though a[great] equals to pivot, the
                     * assignment a[k] = pivot may be incorrect,
                     * if a[great] and pivot are floating-point
                     * zeros of different signs. Therefore in float
                     * and double sorting methods we have to use
                     * more accurate assignment a[k] = a[great].
                     */
                    a[k] = pivot;
                }
                a[great] = ak;
                --great;
            }
        }

				//两侧进行双轴快排
        sort(a, left, less - 1, leftmost);
        sort(a, great + 1, right, false);
    }
}
```

#### Comparable接口数据类型

```java
public static void sort(Object[] a) {
  	//传统归并
    if (LegacyMergeSort.userRequested)
        legacyMergeSort(a);
    else
    //TimSort
        ComparableTimSort.sort(a, 0, a.length, null, 0, 0);
}
```