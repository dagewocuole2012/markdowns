# 排序



## 衡量标准

### 执行效率

之前的算法时间复杂度分析，都是基于**数据量**，反应数据量n很大时候的增长趋势。

但是排序稍有不同，数据**有序性**的不同也会导致时间复杂度的不同『比如一组完全有序的数据，「经过」排序算法的时间复杂度可能是O(n)，因为只有一次遍历；而一组倒序的数据，「经过」排序算法的时间复杂度可能是O($n^2$)』。

以冒泡排序为例「假设数据需要从小到大排列」，n个数据的排列组合方式有 $n!$ 种，使用之前的平均分析，计算每种情况的时间复杂度，再求解平均时间复杂度的方式就会很麻烦，需要涉及到数据推理和大量计算。

> **有序度**和**逆序度**
>
> **有序度**是数据中具有有序关系的数据对个数。以从小到大排序为例，有序关系的数据对可以表示为
>
> ```逻辑公式
> 当i<j时：a[i] <= a[j]
> ```
>
> ```示例
> 「2、4、3、1、5、6」这组数据中，有序的数据对有：
> 「2、4」「2、3」「2、5」「2、6」
> 「4、5」「4、6」
> 「3、5」「3、6」
> 「1、5」「1、6」
> 「5、6」
> 共有11对，所有这组数据的有序度为11。
> ```
>
> ```示例
> 「1、2、3、4、5、6」这组数据，是满有序度，n*(n-1)/2。15。
> 「6、5、4、3、2、1」这组数据，没有一个有序对，0。
> ```
>
> 交换次数总是 **「满有序度-初始有序度」**
>
> ```示例
> 「2、4、3、1、5、6」初始有序度为11，满有序度为15。使用冒泡排序。
> 第一次交换：「2、『3、4』、1、5、6」
> 第二次交换：「2、3、『1、4』、5、6」
> 第三次次交换：「2、『1、3』、4、5、6」
> 第四次次交换：「『1、2』、3、4、5、6」
> 最后一次遍历不交换数据，总共15-11=4次交换。
> ```
>
> **逆序度**跟有序度刚好相反。
>
> ```逻辑公式
> 当i<j时：a[j] > a[j]
> ```
>
> **满有序度 = 逆序度 + 有序度**。排序就是一个增加有序度，减小逆序度的过程。

以冒泡排序为例，经过一次**交换**，**有序度加一**。

- 最好情况：有序度为满有序度，不需要进行交换。

- 最坏情况：有序度为0，需要进行$n(n-1)/2$次交换。
- 平均情况：最好情况和最坏情况取平均值，$n(n-1)/4$

也就是，**冒泡排序的平均时间复杂度为O($n^2$)**。当然这种分析方式并不严格「比较操作比交换操作要多」，但是比起概率论的复杂计算和分析来看，更加实用。

### 空间消耗

这里说的是额外的空间消耗。

- **原地排序**时间复杂度为O(1)。冒泡排序、插入排序、选择排序都是原地排序算法。

### 稳定性

如果存在值相等的元素，经过交换后，他们的先后顺序是否发生改变。

假设有2，9，3，4，8，3一组数据，排序完成后2，3，3，4，8，9。有两个3，如果他们的前后顺序发生变化就是**不稳定排序**；如果前后顺序一致是**稳定排序**。

> 乍一看没什么讲究，但是对于日常的数据排序极为重要。
>
> 假如对订单进行排序，希望按照订单金额从大到小排序，相同订单金额的订单按照下单时间从大到小排序。
>
> - 如果使用不稳定排序：需要对订单金额进行分组，组内按照下单时间排序，然后再对组进行金额排序。比较复杂。
> - 如果使用稳定排序：先按照下单时间排序一遍，再按照订单金额排序一遍，就可以完成。

## 「已排序空间|未排序空间」类型

### 冒泡排序

> 逐个比较相邻的两个元素「i < j」
>
> - 存在 a[i] > a[j]，交换
> - 否则不交换
>
> 一次冒泡，至少会让一个元素移动到它应该在的位置。n个数据，至多经过n次冒泡完成排序。

假设对4，5，6，3，2，1从小到大进行排序，下面是一次冒泡过程

![一次冒泡](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-一次冒泡.png)

经过**一次冒泡**之后，6已经处在正确的位置。那么经过6次排序之后，完成排序。

![image-20201207102759331](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-6次冒泡.png)

6个数据排序6次，不是一个**必要终止排序条件**。

冒泡排序的排序终止条件，应当设为「**当前这一次冒泡是否有数据交换**」，没有数据交换就终止排序。比如下面这组数据：

![image-20201207103731910](https://gitee.com/wangigor/typora-images/raw/master/数据结构与算法-排序-4次冒泡.png)

没有数据交换，就代表已经达到完全有序的状态。

```java
/**
 * 数组冒泡排序「从小到大」
 *
 * @param array 元素数组
 * @param <T>   实现comparable接口的元素类
 */
private <T extends Comparable> void arrayBubbleSort(T[] array) {

    int array_length = array.length;
    if (array_length <= 1) {
        return;
    }
		//外层最多n次冒泡
    for (int i = 0; i < array_length; i++) {
        boolean changed = false;

        for (int j = 0; j < array_length - 1; j++) {
          	//大于才交换
            if (array[j].compareTo(array[j + 1]) > 0) {
                //需要交换
                T temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
                changed = true;//有交换
            }
        }
        if (!changed) {
            return;//当前循环无交换，退出排序
        }
    }

}
```

> 冒泡排序的衡量：
>
> - 时间复杂度为O($n^2$)
> - 空间复杂度为O(1)，只使用了一个temp的外部空间，是原地排序。
> - 是稳定排序。如果「array[j].compareTo(array[j + 1]) > 0」改为「>=0」，相同的元素，关系会被倒转。

### 插入排序

### 选择排序

